import { AuthHandler } from "sst/auth";

import { CodeAdapter } from "sst/auth/adapter";
import { sessions } from "./sessions";
// TODO: #13 I'm kind of a jerk. This won't build because
// we don't have the SES SDK installed. I want you to get used
// to having to install AWS SDK libs as needed (with `pnpm` in this case).
import { SESv2Client, SendEmailCommand } from "@aws-sdk/client-sesv2";
import { Resource } from "sst";
import { handle } from "hono/aws-lambda";
import { z } from "zod";

// TODO: #14 Once we have the SDK `pnpm install`'ed we can new up
// an SESv2Client for sending requests to SES.
const ses = new SESv2Client({});

const claimsSchema = z.object({
  email: z
    .string()
    .min(1, "Please enter your email")
    .email("The email you entered is invalid"),
});

// TODO: #9 Alright, a lot to touch on in here, buckle up. Three key
// elements to defining an AuthHandler. Before we dive into those,
// some context: this is essentially a "factory" for spitting out a
// Lambda Function handler with lots of functionality baked in
// (functionality that the SST team built and maintains).
const app = AuthHandler({
  // TODO: #10 For starters, we pass our sessions object that
  // we just defined and instantiated above. This gives us some
  // TypeScript goodness among other things. Actually, I don't know
  // if it gives us other things; but definitely TypeScript stuff.
  session: sessions,
  // TODO: #11 Next we define "providers". You can define as many as you'd
  // like to handle multiple auth flows your app might need (eg, web and mobile).
  // We're going to create a `code` provider and use the provided `CodeAdapter`
  // to do so. This is a basic flow where the user recieves a code and verifies
  // it. In our case, we'll send it through email, but we wouldn't have to.
  // Could just as easily send it through SMS. Or, much harder, we could
  // send it via the postal service. (Sorry, trying to keep it spicy here with
  // all the reading I'm making you do.)
  //
  // SST also has a GoogleAdapter, GithubAdapter, etc, that are super simple.
  providers: {
    code: CodeAdapter({
      async onCodeRequest(code, unvalidatedClaims, req) {
        const referrer = req.headers.get("referer");
        const claims = claimsSchema.parse(unvalidatedClaims);
        console.log({ code });

        // TODO: #15 Remember when we linked the email resource
        // to our auth resource? This is why. We can grab the
        // "sender" domain/email that was verified in SES from
        // `Resource.Email`. Pretty cool, amirite?
        //
        // NOTE: If you're not using a custom domain and you
        // went with the single email address route, make sure
        // you click the link that Amazon will send you to
        // verify your sender email address.
        const from = Resource.Email.sender.includes("@")
          ? `Peasy <${Resource.Email.sender}>`
          : `Peasy <mail@${Resource.Email.sender}>`;

        // TODO: #12 FINALLY, we get to send an email. `CodeAdapter`
        // allows us to define code to run when a code is requested
        // (this function we're in here) and when the code is
        // invalid (defined in `onCodeInvalid` below).
        //
        // For our auth flow, we just want to send the user an email
        // with the code generated by SST (it's passed into this function).
        //
        // Before we look at the SES SDK call below, need to take you on a
        // little journey to make this work. Go to #13.
        const cmd = new SendEmailCommand({
          // TODO: #16 Next, we grab the potential user's email address
          // from the `claims` provided by the SST authenticator
          // (you'll see the client/browser side in a bit).
          Destination: { ToAddresses: [claims.email] },
          FromEmailAddress: from,
          Content: {
            Simple: {
              Body: {
                Html: { Data: `Your pin code is <strong>${code}</strong>` },
                Text: { Data: `Your pin code is ${code}` },
              },
              Subject: { Data: "Peasy Pin Code: " + code },
            },
          },
        });
        // TODO: #17 And we send the email! That simple. You don't need a
        // SaaS provider for email, it's literally a single API call!
        await ses.send(cmd);

        // TODO: #18 We return a standard `Response` to the caller with
        // a redirect of our choosing. Obviously, this is coupled to our
        // frontend routes. `/auth/verify` is a page that will allow the
        // user to type in the code they receive through the email we sent above.
        return new Response("ok", {
          status: 302,
          headers: {
            location: referrer + "auth/verify?email=" + claims.email,
          },
        });
      },
      async onCodeInvalid(_code, _claims, req) {
        const referrer = req.headers.get("referer");
        return new Response("ok", {
          status: 302,
          headers: {
            location: referrer + "auth/verify?error=invalid_code",
          },
        });
      },
    }),
  },
  callbacks: {
    auth: {
      async allowClient(_clientID, _redirect) {
        return true;
      },
      async success(ctx, input) {
        console.log(input);
        if (input.provider === "code") {
          const email = input.claims.email!.toLowerCase();
          return ctx.session({
            type: "account",
            properties: {
              email,
            },
          });
        }

        return new Response("Not Supported", {
          status: 400,
          headers: { "content-type": "text/plain" },
        });
      },
    },
  },
});

export const handler = handle(app);
